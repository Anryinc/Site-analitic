<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Зарплатный анализ по грейдам</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1"></script>
  <style>
    body { font-family: Arial, sans-serif; max-width: 1200px; margin: 20px auto; padding: 0 12px; background: #f9f9fb; }
    h1 { text-align: center; color: #333; }
    .top-controls { display: flex; justify-content: center; align-items: center; gap: 20px; margin: 15px 0; flex-wrap: wrap; }
    .controls { margin: 20px 0; text-align: center; }
    .controls label { margin: 0 10px; font-weight: bold; }
    select { padding: 6px 10px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; }
    #chart-container { position: relative; width: 100%; max-width: 1100px; height: 500px; margin: 30px auto; background: white; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); overflow: hidden; }
    #chart { height: calc(100% - 50px); width: 100%; }
    #ruler { height: 50px; background: #222; position: relative; border-bottom-left-radius: 12px; border-bottom-right-radius: 12px; }
    .grade-line { position: absolute; width: 4px; height: 100%; top: 0; left: 0; background-color: #000; cursor: ew-resize; z-index: 10; border-radius: 2px; box-shadow: 0 0 10px rgba(0,0,0,0.3); }
    .grade-label { position: absolute; bottom: 5px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; white-space: nowrap; pointer-events: none; }
    .ruler-tick { position: absolute; bottom: 8px; font-size: 11px; color: #aaa; transform: translateX(-50%); }
    #grades-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    #grades-table th, #grades-table td { padding: 10px; text-align: center; border: 1px solid #ddd; }
    #grades-table th { background: #f2f2f2; }
    #grades-table .button-cell { text-align: left; padding-left: 20px; }
    button { padding: 8px 16px; margin: 0 5px; cursor: pointer; border: none; border-radius: 6px; background: #2196F3; color: white; font-weight: bold; }
    button:hover { background: #1976D2; }
    button:disabled { background: #aaa; cursor: not-allowed; }
    .tooltip { position: relative; display: inline-block; }
    .tooltip .tooltiptext { visibility: hidden; width: 250px; background-color: #333; color: #fff; text-align: center; border-radius: 6px; padding: 8px; position: absolute; z-index: 100; bottom: 130%; left: 50%; margin-left: -125px; opacity: 0; transition: opacity 0.3s; font-size: 13px; }
    .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
  </style>
</head>
<body>
  <div class="top-controls">
    <button id="saveBtn">Сохранить позиции грейдов</button>

    <div class="tooltip">
      <label>
        Ориентация по рынку:
        <select id="percentileSelect">
          <option value="5">5-й</option>
          <option value="10">10-й</option>
          <option value="20">20-й</option>
          <option value="30">30-й</option>
          <option value="40">40-й</option>
          <option value="50" selected>50-й (медиана)</option>
          <option value="60">60-й</option>
          <option value="70">70-й</option>
          <option value="80">80-й</option>
          <option value="90">90-й</option>
          <option value="95">95-й</option>
        </select>
      </label>
      <span class="tooltiptext" id="percentileTooltip"></span>
    </div>
  </div>

  <h1>Зарплатный анализ по грейдам</h1>
  <p style="text-align:center;color:#555;">Перетаскивайте цветные линии, чтобы задать границы грейдов</p>

  <div class="controls">
    <label>Вакансия: <select id="vacancyFilter"></select></label>
    <label>Город: <select id="cityFilter"><option value="">Все</option></select></label>
    <label>Квартал: <select id="quarterFilter"></select></label>
    <label>Шаг ЗП:
      <select id="stepFilter">
        <option value="5">5 тыс</option>
        <option value="10">10 тыс</option>
        <option value="20" selected>20 тыс</option>
        <option value="50">50 тыс</option>
      </select>
    </label>
  </div>

  <div id="chart-container">
    <canvas id="chart"></canvas>
    <div id="ruler"></div>
  </div>

  <table id="grades-table"></table>

  <script>
    let allData = [];
    let chartInstance = null;
    let subLevel = 1;
    let marketPercentile = 50;
    let currentStep = 20;
    let currentLabels = [];

    const subPercentiles = {
      1: [50],
      2: [30, 70],
      3: [20, 50, 80],
      4: [15, 35, 65, 85],
      5: [10, 30, 50, 70, 90]
    };

    const grades = [
      { name: "Intern", color: "#FF9800", value: 60 },
      { name: "Junior", color: "#4CAF50", value: 140 },
      { name: "Middle", color: "#2196F3", value: 280 },
      { name: "Senior", color: "#9C27B0", value: 500 },
      { name: "Lead", color: "#F44336", value: 800 },
      { name: "End", color: "#000000", value: 900 }
    ];

    // КНОПКА СОХРАНЕНИЯ (одна!)
    document.getElementById('saveBtn').addEventListener('click', async () => {
      const vacancy = document.getElementById('vacancyFilter').value;
      if (!vacancy) return alert('Выберите вакансию');

      const positions = {};
      grades.forEach(g => positions[g.name.toLowerCase()] = g.value);

      try {
        const res = await fetch('/api/save_positions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ vacancy_category: vacancy, positions })
        });

        if (res.ok || res.status === 204) {
          alert('Позиции успешно сохранены!');
        } else {
          const txt = await res.text();
          alert('Ошибка сохранения: ' + txt);
        }
      } catch (e) {
        alert('Сетевая ошибка: ' + e);
      }
    });

    // PERCENTILE SELECT + БЛОКИРОВКА
    const percentileSelect = document.getElementById('percentileSelect');
    const percentileTooltip = document.getElementById('percentileTooltip');

    function updatePercentileState() {
      const isSingle = subLevel === 1;
      const isMedian = marketPercentile === 50;

      percentileSelect.disabled = !isSingle;
      percentileTooltip.textContent = isSingle
        ? (isMedian ? '' : 'доступно только при 50-м перцентиле')
        : 'доступно только при 1 субгрейде';

      // Блокировка кнопки "+"
      document.querySelectorAll('button').forEach(b => {
        if (b.textContent.includes('+ добавить субгрейд')) {
          b.disabled = !isMedian;
        }
      });
    }

    percentileSelect.addEventListener('change', () => {
      marketPercentile = +percentileSelect.value;
      updatePercentileState();
      calculateMedians();
    });

    // === ВСЁ ОСТАЛЬНОЕ (loadData, renderChart, calculateMedians и т.д.) ===
    function getQuarter(dateStr) {
      const d = new Date(dateStr);
      if (isNaN(d)) return '';
      const year = d.getFullYear();
      const q = Math.floor(d.getMonth() / 3) + 1;
      return `${year} Q${q}`;
    }

    async function loadData() {
      const res = await fetch('/api/analytics?limit=1000');
      if (!res.ok) {
        document.body.innerHTML += `<p style="color:red">Ошибка загрузки данных</p>`;
        return;
      }
      allData = await res.json();

      // Загружаем сохранённые позиции для текущей вакансии
      const currentVacancy = document.getElementById('vacancyFilter').value || allData[0]?.vacancy_category;
      const saved = allData.find(r => r.vacancy_category === currentVacancy);
      if (saved?.grades_positions) {
        Object.entries(saved.grades_positions).forEach(([k, v]) => {
          const g = grades.find(g => g.name.toLowerCase() === k);
          if (g) g.value = v;
        });
      }

      fillFilters(allData);
      renderChart();
      calculateMedians();
      updatePercentileState();
    }

    function fillFilters(data) {
      const vacancySet = new Set(), citySet = new Set(), quarterSet = new Set();
      data.forEach(r => {
        if (r.vacancy_category) vacancySet.add(r.vacancy_category);
        if (r.city && r.city !== 'Все города') citySet.add(r.city);
        if (r.upload_date) quarterSet.add(getQuarter(r.upload_date));
      });

      const vSel = document.getElementById('vacancyFilter');
      vSel.innerHTML = [...vacancySet].sort().map(v => `<option value="${v}">${v}</option>`).join('');
      if (!vSel.value && vacancySet.size) vSel.value = [...vacancySet][0];

      document.getElementById('cityFilter').innerHTML = '<option value="">Все</option>' +
        [...citySet].sort().map(v => `<option value="${v}">${v}</option>`).join('');

      const quarters = [...quarterSet].sort((a,b) => b.localeCompare(a));
      document.getElementById('quarterFilter').innerHTML = quarters.map(v => `<option value="${v}">${v}</option>`).join('');
      if (quarters.length) document.getElementById('quarterFilter').value = quarters[0];
    }

    function parseSalaryData(jsonField) {
      if (!jsonField || typeof jsonField !== 'object') return {};
      return jsonField;
    }

    function filterData() {
      const vacancy = document.getElementById('vacancyFilter').value;
      const city = document.getElementById('cityFilter').value;
      const quarter = document.getElementById('quarterFilter').value;

      return allData.filter(r => {
        const matchesVacancy = r.vacancy_category === vacancy;
        const matchesCity = city === '' ? r.city === 'Все города' : r.city === city;
        const matchesQuarter = getQuarter(r.upload_date) === quarter;
        return matchesVacancy && matchesCity && matchesQuarter;
      });
    }

    function aggregateData(rawByRange, step) {
      const aggregated = {};
      let start = 0;
      while (start < 1000) {
        const end = start + step;
        const key = start === 0 ? `less_${end}k` : `${start}k_${end}k`;
        let sum = 0;

        for (const rangeKey in rawByRange) {
          if (rangeKey === 'more_1000k') continue;
          if (rangeKey === 'less_5k') {
            if (start === 0) sum += rawByRange[rangeKey] || 0;
            continue;
          }
          const [lStr, hStr] = rangeKey.split('_');
          const low = parseInt(lStr.replace('k', ''));
          const high = parseInt(hStr.replace('k', ''));
          if (low >= start && high <= end) {
            sum += rawByRange[rangeKey] || 0;
          }
        }
        aggregated[key] = sum;
        start = end;
      }
      aggregated['more_1000k'] = rawByRange['more_1000k'] || 0;
      return aggregated;
    }

    function formatLabels(aggregatedRanges, step) {
      return aggregatedRanges.map(key => {
        if (key === 'more_1000k') return `выше 1000`;
        if (key.startsWith('less_')) {
          const limit = key.match(/less_(\d+)k/)[1];
          return `до ${limit}`;
        }
        const match = key.match(/(\d+)k_\d+k/);
        if (match) {
          return match[1];
        }
        return key;
      });
    }

    function getRangeForKey(key) {
      if (key === 'less_5k') return { low: 0, high: 5 };
      if (key === 'more_1000k') return { low: 1000, high: Infinity };
      const [lStr, hStr] = key.split('_').map(x => parseInt(x.replace('k','')));
      return { low: lStr, high: hStr };
    }

    function percentile(arr, p) {
      arr = arr.filter(v => v != null).sort((a, b) => a - b);
      if (arr.length === 0) return 'N/A';
      const index = (p / 100) * (arr.length - 1);
      const lower = Math.floor(index);
      const upper = lower + 1;
      const weight = index % 1;
      if (upper >= arr.length) return Math.round(arr[lower]);
      return Math.round(arr[lower] * (1 - weight) + arr[upper] * weight);
    }

    function calculateMedians() {
      const data = filterData();
      if (data.length === 0) return;

      const table = document.getElementById('grades-table');
      table.innerHTML = '';

      // Header
      const header = table.insertRow();
      header.insertCell().textContent = '';
      grades.slice(0, -1).forEach(g => {
        const th = header.insertCell();
        th.textContent = g.name;
      });

      // Subgrade rows
      const percs = subPercentiles[subLevel];
      for (let j = 0; j < subLevel; j++) {
        const row = table.insertRow();
        row.insertCell().textContent = `Субгрейд ${j + 1}`;
        for (let i = 0; i < grades.length - 1; i++) {
          const start = grades[i].value;
          const end = grades[i+1].value;

          const percentiles = [];
          data.forEach(rec => {
            ['res_percentiles_json', 'vac_percentiles_json'].forEach(field => {
              const json = parseSalaryData(rec[field]);
              for (const key in json) {
                const { low, high } = getRangeForKey(key);
                if (high <= start || low >= end) continue;
                json[key].filter(v => v !== null).forEach(v => percentiles.push(v));
              }
            });
          });

          const val = percentiles.length ? percentile(percentiles, percs[j]) : 'N/A';
          row.insertCell().textContent = val;
        }
      }

      // Button row
      const buttonRow = table.insertRow();
      const buttonCell = buttonRow.insertCell();
      buttonCell.colSpan = grades.length;
      buttonCell.className = 'button-cell';

      if (subLevel < 5) {
        const addBtn = document.createElement('button');
        addBtn.textContent = '+ добавить субгрейд';
        addBtn.onclick = () => {
          subLevel++;
          calculateMedians();
        };
        buttonCell.appendChild(addBtn);
      }

      if (subLevel > 1) {
        const removeBtn = document.createElement('button');
        removeBtn.textContent = '- убрать субгрейд';
        removeBtn.onclick = () => {
          subLevel--;
          calculateMedians();
        };
        buttonCell.appendChild(removeBtn);
      }
    }

    function renderChart() {
      const data = filterData();

      const baseResumes = {};
      const baseVacancies = {};
      const baseRanges = new Set();

      data.forEach(record => {
        const resumes = parseSalaryData(record.resumes_pct_json);
        const vacancies = parseSalaryData(record.vacancies_pct_json);
        Object.keys(resumes).forEach(k => baseRanges.add(k));
        Object.keys(vacancies).forEach(k => baseRanges.add(k));
      });

      const sortedBase = Array.from(baseRanges).sort((a, b) => {
        const order = ['less_5k', ...Array.from({length:200}, (_, i) => `${(i+1)*5}k_${(i+2)*5}k`), 'more_1000k'];
        return order.indexOf(a) - order.indexOf(b);
      });

      sortedBase.forEach(range => {
        let rSum = 0, rCnt = 0, vSum = 0, vCnt = 0;
        data.forEach(rec => {
          if (rec.resumes_pct_json && rec.resumes_pct_json[range] !== undefined) {
            rSum += rec.resumes_pct_json[range];
            rCnt++;
          }
          if (rec.vacancies_pct_json && rec.vacancies_pct_json[range] !== undefined) {
            vSum += rec.vacancies_pct_json[range];
            vCnt++;
          }
        });
        baseResumes[range] = rCnt ? rSum / rCnt : 0;
        baseVacancies[range] = vCnt ? vSum / vCnt : 0;
      });

      currentStep = parseInt(document.getElementById('stepFilter').value) || 20;

      const aggResumes = aggregateData(baseResumes, currentStep);
      const aggVacancies = aggregateData(baseVacancies, currentStep);
      const rawLabels = Object.keys(aggResumes);
      currentLabels = formatLabels(rawLabels, currentStep);

      // Sort grades to prevent crossing
      grades.sort((a, b) => a.value - b.value);

      // Annotations for fills (using grade colors)
      const annotations = [];
      for (let i = 0; i < grades.length - 1; i++) {
        let startIdx = currentLabels.findIndex(l => {
          const val = l.startsWith('до') ? 0 : parseInt(l) || Infinity;
          return val >= grades[i].value;
        });
        let endIdx = currentLabels.findIndex(l => {
          const val = l.startsWith('до') ? 0 : parseInt(l) || Infinity;
          return val >= grades[i+1].value;
        });
        if (startIdx === -1) startIdx = 0;
        if (endIdx === -1) endIdx = currentLabels.length - 1;
        annotations.push({
          type: 'box',
          xMin: startIdx - 0.3,
          xMax: endIdx + 0.3,
          yMin: 0,
          yMax: 'max',
          backgroundColor: grades[i].color + '2A',
          borderWidth: 0
        });
      }

      const ctx = document.getElementById('chart').getContext('2d');
      if (chartInstance) chartInstance.destroy();

      chartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: currentLabels,
          datasets: [
            {
              label: 'Резюме %',
              data: Object.values(aggResumes),
              type: 'line',
              borderColor: 'rgba(54,162,235,0.9)',
              backgroundColor: 'rgba(54,162,235,0.1)',
              tension: 0.2,
              fill: true,
              pointRadius: 1,
              borderWidth: 1,
              order: 1
            },
            {
              label: 'Вакансии %',
              data: Object.values(aggVacancies),
              type: 'bar',
              backgroundColor: 'rgba(255,99,132,0.6)',
              borderColor: 'rgba(255,99,132,1)',
              borderWidth: 1,
              barThickness: 10,
              order: 2
            }
          ]
        },
        options: {
          plugins: { legend: { position: 'top' }, annotation: { annotations } },
          scales: { 
            x: { ticks: { autoSkip: false, maxRotation: 90, minRotation: 90 } }, 
            y: { beginAtZero: true, ticks: { display: false } }
          },
          interaction: { mode: 'index', intersect: false },
          responsive: true,
          maintainAspectRatio: false
        }
      });

      // Ruler
      const ruler = document.getElementById('ruler');
      ruler.innerHTML = '';
      const containerWidth = document.getElementById('chart-container').clientWidth;
      currentLabels.forEach((label, i) => {
        const tick = document.createElement('div');
        tick.className = 'ruler-tick';
        tick.style.left = `${(i / (currentLabels.length - 1)) * 100}%`;
        tick.textContent = label;
        ruler.appendChild(tick);
      });

      // Lines
      const container = document.getElementById('chart-container');
      grades.forEach((g, i) => {
        let line = document.getElementById(`grade-line-${g.name}`);
        if (!line) {
          line = document.createElement('div');
          line.id = `grade-line-${g.name}`;
          line.className = 'grade-line';
          line.style.backgroundColor = g.color;
          line.dataset.index = i;

          const label = document.createElement('div');
          label.className = 'grade-label';
          label.textContent = g.name;
          line.appendChild(label);

          container.appendChild(line);

          let dragging = false;
          line.addEventListener('mousedown', e => { dragging = true; e.preventDefault(); });
          document.addEventListener('mousemove', e => {
            if (!dragging) return;
            const rect = container.getBoundingClientRect();
            let newX = e.clientX - rect.left;
            newX = Math.max(0, Math.min(containerWidth, newX));
            let newValue = Math.round((newX / containerWidth) * 1000 / currentStep) * currentStep;

            // Limits
            const prevValue = i > 0 ? grades[i-1].value : 0;
            const nextValue = i < grades.length - 1 ? grades[i+1].value : Infinity;
            newValue = Math.max(prevValue, Math.min(nextValue, newValue));

            g.value = newValue;
            line.style.left = `${(g.value / 1000) * containerWidth}px`;
          });
          document.addEventListener('mouseup', () => {
            if (dragging) {
              dragging = false;
              renderChart();
              calculateMedians();
            }
          });
        }
        line.style.left = `${(g.value / 1000) * containerWidth}px`;
      });
    }


    

    // При загрузке данных - загрузка позиций из allData
    async function loadData() {
      const res = await fetch('/api/analytics?limit=1000');
      if (!res.ok) {
        document.body.innerHTML += `<p style="color:red">Ошибка загрузки: ${res.status}</p>`;
        return;
      }
      allData = await res.json();
      const vacancy = document.getElementById('vacancyFilter').value;
      const row = allData.find(r => r.vacancy_category === vacancy);
      if (row && row.grades_positions) {
        Object.keys(row.grades_positions).forEach(key => {
          const g = grades.find(gg => gg.name.toLowerCase() === key);
          if (g) g.value = row.grades_positions[key];
        });
      }
      fillFilters(allData);
      renderChart();
      calculateMedians();
    }

    // Слушатель смены вакансии - reload positions
    document.getElementById('vacancyFilter').addEventListener('change', () => {
      const vacancy = document.getElementById('vacancyFilter').value;
      const row = allData.find(r => r.vacancy_category === vacancy);
      if (row && row.grades_positions) {
        Object.keys(row.grades_positions).forEach(key => {
          const g = grades.find(gg => gg.name.toLowerCase() === key);
          if (g) g.value = row.grades_positions[key];
        });
      } else {
        // Default if no saved
        grades[0].value = 60;
        grades[1].value = 140;
        grades[2].value = 280;
        grades[3].value = 500;
        grades[4].value = 800;
        grades[5].value = 900;
      }
      renderChart();
      calculateMedians();
    });

window.addEventListener('DOMContentLoaded', () => {
      ['vacancyFilter','cityFilter','quarterFilter','stepFilter'].forEach(id => {
        document.getElementById(id).addEventListener('change', () => {
          renderChart();
          calculateMedians();
        });
      });

      // При смене вакансии — перезагружаем позиции
      document.getElementById('vacancyFilter').addEventListener('change', () => {
        const vacancy = document.getElementById('vacancyFilter').value;
        const row = allData.find(r => r.vacancy_category === vacancy);
        if (row?.grades_positions) {
          Object.entries(row.grades_positions).forEach(([k, v]) => {
            const g = grades.find(g => g.name.toLowerCase() === k);
            if (g) g.value = v;
          });
        } else {
          // дефолт
          grades.forEach((g, i) => g.value = [60,140,280,500,800,900][i]);
        }
        renderChart();
        calculateMedians();
      });

      loadData();
    });
  </script>
</body>
</html>
