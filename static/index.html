<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Зарплатный анализ по грейдам</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 1200px; margin: 20px auto; padding: 0 12px; background: #f9f9fb; }
    h1 { text-align: center; color: #333; }
    .top-controls { display: flex; justify-content: center; align-items: center; gap: 20px; margin: 15px 0; flex-wrap: wrap; }
    .controls { margin: 20px 0; text-align: center; }
    .controls label { margin: 0 10px; font-weight: bold; }
    select { padding: 6px 10px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; }
    #chart-container { position: relative; display: flex; width: 100%; max-width: 1100px; height: 500px; margin: 30px auto; background: white; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); overflow: hidden; }
    .bin { flex: 1; position: relative; height: 100%; border-right: 1px solid #ddd; }
    .bin:last-child { border-right: none; }
    .vacancy-bar { position: absolute; bottom: 50px; left: 10%; width: 30%; background-color: rgba(255,99,132,0.6); transition: height 0.3s; }
    .resume-bar { position: absolute; bottom: 50px; left: 60%; width: 30%; background-color: rgba(54,162,235,0.1); border: 1px solid rgba(54,162,235,0.9); transition: height 0.3s; }
    .bin-label { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%) rotate(90deg); font-size: 11px; color: #aaa; white-space: nowrap; }
    .grade-line { position: absolute; top: 0; width: 4px; height: calc(100% - 50px + 40px); background-color: #000; cursor: ew-resize; z-index: 10; border-radius: 2px; box-shadow: 0 0 10px rgba(0,0,0,0.3); }
    .grade-value { position: absolute; top: -25px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; white-space: nowrap; pointer-events: none; }
    .grade-label { position: absolute; bottom: -35px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; white-space: nowrap; pointer-events: none; }
    #grades-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    #grades-table th, #grades-table td { padding: 10px; text-align: center; border: 1px solid #ddd; }
    #grades-table th { background: #f2f2f2; }
    button { padding: 8px 16px; margin: 5px; cursor: pointer; border: none; border-radius: 6px; background: #2196F3; color: white; font-weight: bold; }
    button:hover { background: #1976D2; }
    .tooltip { position: relative; display: inline-block; }
    .tooltip .tooltiptext { visibility: hidden; width: 220px; background-color: #333; color: #fff; text-align: center; border-radius: 6px; padding: 8px; position: absolute; z-index: 1; bottom: 130%; left: 50%; margin-left: -110px; opacity: 0; transition: opacity 0.3s; font-size: 13px; }
    .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
    #pro-mode-controls { display: none; text-align: center; margin: 10px 0; }
    #pro-mode-controls.active { display: block; }
    #pro-mode-controls label { display: block; margin: 5px 0; }
    .legend { display: flex; justify-content: center; align-items: center; gap: 20px; margin: 10px 0; font-size: 14px; }
    .legend-item { display: flex; align-items: center; gap: 8px; }
    .legend-color { width: 20px; height: 20px; border-radius: 4px; }
  </style>
</head>
<body>
  <div class="top-controls">
    <button id="saveBtn">Сохранить позиции грейдов</button>
    <div class="tooltip">
      <label>
        Ориентация по рынку:
        <select id="percentileSelect">
          <option value="5">5-й</option>
          <option value="10">10-й</option>
          <option value="20">20-й</option>
          <option value="30">30-й</option>
          <option value="40">40-й</option>
          <option value="50" selected>50-й (медиана)</option>
          <option value="60">60-й</option>
          <option value="70">70-й</option>
          <option value="80">80-й</option>
          <option value="90">90-й</option>
          <option value="95">95-й</option>
        </select>
      </label>
      <span class="tooltiptext" id="percentileTooltip"></span>
    </div>
  </div>

  <h1>Зарплатный анализ по грейдам</h1>
  <p style="text-align:center;color:#555;">Перетаскивайте цветные линии, чтобы задать границы грейдов</p>

  <div class="controls">
    <label>Вакансия: <select id="vacancyFilter"></select></label>
    <label>Город: <select id="cityFilter"><option value="">Все города</option></select></label>
    <label>Квартал: <select id="quarterFilter"><option value="">Все</option></select></label>
    <label>Шаг ЗП: 
      <select id="stepFilter">
        <option value="5">5 тыс</option>
        <option value="10">10 тыс</option>
        <option value="20" selected>20 тыс</option>
        <option value="50">50 тыс</option>
      </select>
    </label>
  </div>

  <div class="legend">
    <div class="legend-item"><div class="legend-color" style="background: rgba(54,162,235,0.9);"></div>Резюме %</div>
    <div class="legend-item"><div class="legend-color" style="background: rgba(255,99,132,0.6);"></div>Вакансии %</div>
  </div>

  <label style="display: block; text-align: center; margin-bottom: 10px;">
    <input type="checkbox" id="pro-mode-switch"> Pro Mode (настройка зоны линий)
  </label>

  <div id="pro-mode-controls">
    <label>Ширина зоны: <input type="range" id="linesWidthSlider" min="600" max="1500" value="1100" step="10"></label>
    <label>Высота зоны: <input type="range" id="linesHeightSlider" min="300" max="800" value="500" step="10"></label>
  </div>

  <div id="chart-container"></div>

  <table id="grades-table"></table>

  <script>
    let allData = [];
    let subLevel = 1;
    let marketPercentile = 50;
    let currentStep = 20;
    let currentLabels = [];
    let currentRawKeys = [];

    const subPercentiles = {
      1: [50],
      2: [30, 70],
      3: [20, 50, 80],
      4: [15, 35, 65, 85],
      5: [10, 30, 50, 70, 90]
    };

    const baseGrades = [
      { name: "Intern", color: "#FF9800", value: 60 },
      { name: "Junior", color: "#4CAF50", value: 140 },
      { name: "Middle", color: "#2196F3", value: 280 },
      { name: "Senior", color: "#9C27B0", value: 500 },
      { name: "Lead", color: "#F44336", value: 800 }
    ];

    let grades = [...baseGrades, { name: "End", color: "#000000", value: 900 }];

    // Кнопка сохранения (без изменений)
    document.getElementById('saveBtn').addEventListener('click', async () => {
      const vacancy = document.getElementById('vacancyFilter').value;
      if (!vacancy) return alert('Выберите вакансию');
      const positions = {};
      baseGrades.forEach(g => positions[g.name.toLowerCase()] = g.value);
      try {
        const res = await fetch('/api/save_positions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ vacancy_category: vacancy, positions })
        });
        if (res.ok || res.status === 204) {
          alert('Позиции успешно сохранены!');
        } else {
          const txt = await res.text();
          alert('Ошибка сохранения: ' + txt);
        }
      } catch (e) {
        alert('Сетевая ошибка: ' + e.message);
      }
    });

    const percentileSelect = document.getElementById('percentileSelect');
    const percentileTooltip = document.getElementById('percentileTooltip');

    function updatePercentileState() {
      const isSingle = subLevel === 1;
      percentileSelect.disabled = !isSingle;
      percentileTooltip.textContent = isSingle ? 'Выберите рыночный перцентиль для медианы грейда' : 'Доступно только при одном уровне грейда';
    }

    percentileSelect.addEventListener('change', e => {
      marketPercentile = parseInt(e.target.value);
      calculateMedians();
    });

    async function loadData() {
      try {
        const res = await fetch('/api/analytics?limit=500');
        if (!res.ok) throw new Error('Failed to fetch');
        allData = await res.json();
        populateFilters();
        renderVisualization();
        calculateMedians();
        updatePercentileState();
      } catch (e) {
        alert('Ошибка загрузки данных: ' + e.message);
        console.error(e);
      }
    }

    // populateFilters, filterData — без изменений

    function populateFilters() {
      const vacancies = new Set();
      const cities = new Set();
      const quarters = new Set();

      allData.forEach(rec => {
        if (rec.vacancy_category) vacancies.add(rec.vacancy_category);
        if (rec.city) cities.add(rec.city);
        if (rec.quarter) quarters.add(rec.quarter);
      });

      const vacancyFilter = document.getElementById('vacancyFilter');
      vacancyFilter.innerHTML = '';
      vacancies.forEach(v => {
        const opt = document.createElement('option');
        opt.value = opt.textContent = v;
        vacancyFilter.appendChild(opt);
      });

      const cityFilter = document.getElementById('cityFilter');
      cityFilter.innerHTML = '<option value="">Все города</option>';
      cities.forEach(c => {
        const opt = document.createElement('option');
        opt.value = opt.textContent = c;
        cityFilter.appendChild(opt);
      });
      cityFilter.value = '';

      const quarterFilter = document.getElementById('quarterFilter');
      quarterFilter.innerHTML = '<option value="">Все</option>';
      quarters.forEach(q => {
        const opt = document.createElement('option');
        opt.value = opt.textContent = q;
        quarterFilter.appendChild(opt);
      });
    }

    function filterData() {
      const vacancy = document.getElementById('vacancyFilter').value;
      const city = document.getElementById('cityFilter').value;
      const quarter = document.getElementById('quarterFilter').value;

      return allData.filter(rec => 
        (!vacancy || rec.vacancy_category === vacancy) &&
        (!city || rec.city === city) &&
        (!quarter || rec.quarter === quarter)
      );
    }

    function parseSalaryData(json_str) {
      if (!json_str) return {};
      try {
        return JSON.parse(json_str);
      } catch (e) {
        console.error('JSON parse error:', e, json_str);
        return {};
      }
    }

    function aggregateData(baseData, step) {
      const agg = {};
      const sortedKeys = Object.keys(baseData).sort((a, b) => parseRange(a) - parseRange(b));

      let currentLow = null;
      let currentSum = 0;

      for (const key of sortedKeys) {
        if (key.startsWith('less_') || key.startsWith('more_')) {
          agg[key] = (agg[key] || 0) + (baseData[key] || 0);
          continue;
        }

        const low = parseRange(key);

        if (currentLow === null || low >= currentLow + step || low % step === 0) {
          if (currentLow !== null) {
            agg[`${currentLow}k_${currentLow + step}k`] = currentSum;
          }
          currentLow = Math.floor(low / step) * step;
          currentSum = baseData[key] || 0;
        } else {
          currentSum += baseData[key] || 0;
        }
      }

      if (currentLow !== null) {
        agg[`${currentLow}k_${currentLow + step}k`] = currentSum;
      }

      return agg;
    }

    function parseRange(r) {
      if (r.startsWith('less_')) return -Infinity;
      if (r.startsWith('more_')) return Infinity;
      return parseInt(r.split('_')[0].replace('k', ''));
    }

    function formatLabels(rawKeys, step) {
      return rawKeys.map(key => {
        if (key.startsWith('less_')) return 'до ' + key.replace('less_', '').replace('k', '');
        if (key.startsWith('more_')) return 'свыше ' + key.replace('more_', '').replace('k', '');
        const low = parseInt(key.split('k_')[0]);
        return `${low}-${low + step}`;
      });
    }

    function getStart(raw) {
      if (raw.startsWith('less_')) return -Infinity;
      if (raw.startsWith('more_')) return Infinity;
      return parseInt(raw.split('k_')[0]);
    }

    function getBinLabel(start, step) {
      if (start === -Infinity) return 'до ...';
      if (start === Infinity) return 'свыше ...';
      return `${start}-${start + step}`;
    }

    function calculateMedians() {
      const data = filterData();
      if (data.length === 0) {
        document.getElementById('grades-table').innerHTML = '<tr><td>Нет данных</td></tr>';
        return;
      }

      const combined = {};
      data.forEach(rec => {
        const r = parseSalaryData(rec.resumes_pct_json);
        const v = parseSalaryData(rec.vacancies_pct_json);
        Object.entries(r).forEach(([k, val]) => combined[k] = (combined[k] || 0) + val);
        Object.entries(v).forEach(([k, val]) => combined[k] = (combined[k] || 0) + val);
      });

      const aggCombined = aggregateData(combined, currentStep);

      const table = document.getElementById('grades-table');
      table.innerHTML = '';

      const headerRow = table.insertRow();
      baseGrades.forEach(g => {
        const th = document.createElement('th');
        th.textContent = g.name;
        headerRow.appendChild(th);
      });

      const medianRow = table.insertRow();
      baseGrades.forEach((g, i) => {
        const nextVal = i < baseGrades.length - 1 ? baseGrades[i + 1].value : grades[grades.length - 1].value;
        let cumulative = 0;
        let total = 0;
        Object.keys(aggCombined).sort((a,b) => getStart(a) - getStart(b)).forEach(k => {
          const start = getStart(k);
          if (start >= g.value && start < nextVal) {
            const val = aggCombined[k] || 0;
            total += val;
          }
        });

        if (total === 0) {
          medianRow.insertCell().textContent = 'N/A';
          return;
        }

        let found = false;
        Object.keys(aggCombined).sort((a,b) => getStart(a) - getStart(b)).forEach(k => {
          const start = getStart(k);
          if (start >= g.value && start < nextVal) {
            const val = aggCombined[k] || 0;
            cumulative += val;
            if (cumulative >= total * 0.5 && !found) {
              found = true;
              const low = getStart(k);
              medianRow.insertCell().textContent = Math.round(low + currentStep / 2) + 'k';
            }
          }
        });
        if (!found) medianRow.insertCell().textContent = 'N/A';
      });

      // Субгрейды (заглушка, можно доработать)
      for (let l = 2; l <= subLevel; l++) {
        const row = table.insertRow();
        baseGrades.forEach(() => row.insertCell().textContent = '-');
      }

      // Кнопки
      const btnRow = table.insertRow();
      const btnCell = btnRow.insertCell();
      btnCell.colSpan = baseGrades.length;
      btnCell.style.textAlign = 'center';

      if (subLevel < 5) {
        const add = document.createElement('button');
        add.textContent = '+ добавить субгрейд';
        add.onclick = () => { subLevel++; updatePercentileState(); calculateMedians(); };
        btnCell.appendChild(add);
      }
      if (subLevel > 1) {
        const rem = document.createElement('button');
        rem.textContent = '- убрать субгрейд';
        rem.onclick = () => { subLevel--; updatePercentileState(); calculateMedians(); };
        btnCell.appendChild(rem);
      }
    }

    function renderVisualization() {
      const data = filterData();
      if (data.length === 0) {
        document.getElementById('chart-container').innerHTML = '<div style="width:100%;text-align:center;padding:100px;">Нет данных для отображения</div>';
        return;
      }

      const baseResumes = {}, baseVacancies = {}, ranges = new Set();

      data.forEach(rec => {
        const r = parseSalaryData(rec.resumes_pct_json);
        const v = parseSalaryData(rec.vacancies_pct_json);
        Object.keys(r).forEach(k => ranges.add(k));
        Object.keys(v).forEach(k => ranges.add(k));
      });

      const sortedRanges = Array.from(ranges).sort((a, b) => parseRange(a) - parseRange(b));

      sortedRanges.forEach(range => {
        let rSum = 0, rCnt = 0, vSum = 0, vCnt = 0;
        data.forEach(rec => {
          const rv = parseSalaryData(rec.resumes_pct_json)[range];
          if (rv !== undefined) { rSum += rv; rCnt++; }
          const vv = parseSalaryData(rec.vacancies_pct_json)[range];
          if (vv !== undefined) { vSum += vv; vCnt++; }
        });
        baseResumes[range] = rCnt > 0 ? rSum / rCnt : 0;
        baseVacancies[range] = vCnt > 0 ? vSum / vCnt : 0;
      });

      currentStep = parseInt(document.getElementById('stepFilter').value) || 20;

      const aggResumes = aggregateData(baseResumes, currentStep);
      const aggVacancies = aggregateData(baseVacancies, currentStep);

      currentRawKeys = Object.keys(aggResumes).sort((a, b) => getStart(a) - getStart(b));
      currentLabels = formatLabels(currentRawKeys, currentStep);

      const container = document.getElementById('chart-container');
      container.innerHTML = '';

      let maxPct = 1; // минимально, чтобы бары были видны даже при малых %
      currentRawKeys.forEach(k => {
        maxPct = Math.max(maxPct, aggResumes[k] || 0, aggVacancies[k] || 0);
      });

      const availableHeight = container.clientHeight - 80;
      const scale = availableHeight / maxPct;

      currentRawKeys.forEach((raw, idx) => {
        const bin = document.createElement('div');
        bin.className = 'bin';
        bin.dataset.raw = raw;
        bin.dataset.start = getStart(raw);

        const vHeight = (aggVacancies[raw] || 0) * scale;
        const rHeight = (aggResumes[raw] || 0) * scale;

        const vBar = document.createElement('div');
        vBar.className = 'vacancy-bar';
        vBar.style.height = `${vHeight}px`;
        bin.appendChild(vBar);

        const rBar = document.createElement('div');
        rBar.className = 'resume-bar';
        rBar.style.height = `${rHeight}px`;
        bin.appendChild(rBar);

        const label = document.createElement('div');
        label.className = 'bin-label';
        label.textContent = currentLabels[idx];
        bin.appendChild(label);

        container.appendChild(bin);
      });

      // Фон грейдов
      grades.sort((a, b) => a.value - b.value);
      const bins = container.querySelectorAll('.bin');
      let gradeIdx = 0;
      bins.forEach(bin => {
        const start = getStart(bin.dataset.raw);
        while (gradeIdx < grades.length - 1 && start >= grades[gradeIdx + 1].value) gradeIdx++;
        bin.style.backgroundColor = grades[gradeIdx].color + '2A';
      });

      // Линии грейдов
      grades.forEach((g, i) => {
        let line = document.getElementById(`grade-line-${g.name}`);
        if (!line) {
          line = document.createElement('div');
          line.id = `grade-line-${g.name}`;
          line.className = 'grade-line';
          line.style.backgroundColor = g.color;

          const valDiv = document.createElement('div');
          valDiv.className = 'grade-value';
          line.appendChild(valDiv);

          const nameDiv = document.createElement('div');
          nameDiv.className = 'grade-label';
          nameDiv.textContent = g.name;
          line.appendChild(nameDiv);

          container.appendChild(line);

          let dragging = false;
          line.addEventListener('mousedown', () => dragging = true);
          document.addEventListener('mousemove', e => {
            if (!dragging) return;
            const rect = container.getBoundingClientRect();
            let x = e.clientX - rect.left;
            x = Math.max(0, Math.min(rect.width, x));
            line.style.left = `${x}px`;
          });
          document.addEventListener('mouseup', () => {
            if (dragging) {
              dragging = false;

              // Snap to nearest bin left edge
              let bestX = 0;
              let bestStart = grades[i > 0 ? i-1 : 0].value + currentStep; // fallback
              let cum = 0;
              bins.forEach(bin => {
                const binCenter = cum + bin.clientWidth / 2;
                if (Math.abs(binCenter - parseFloat(line.style.left)) < Math.abs(binCenter - (bestX + bins[0].clientWidth / 2))) {
                  bestX = cum;
                  bestStart = parseFloat(bin.dataset.start);
                }
                cum += bin.clientWidth;
              });

              // Respect bounds
              const prev = i > 0 ? grades[i-1].value : 0;
              const next = i < grades.length - 1 ? grades[i+1].value : Infinity;
              if (bestStart < prev) bestStart = prev + currentStep;
              if (bestStart >= next) bestStart = next - currentStep;
              g.value = bestStart;

              line.style.left = `${bestX}px`;
              line.querySelector('.grade-value').textContent = getBinLabel(g.value, currentStep);

              renderVisualization();
              calculateMedians();
            }
          });
        }

        // Position line
        let cumX = 0;
        let positioned = false;
        bins.forEach(bin => {
          if (parseFloat(bin.dataset.start) === g.value) {
            line.style.left = `${cumX}px`;
            positioned = true;
          }
          cumX += bin.clientWidth;
        });
        if (!positioned) {
          // fallback snap
          cumX = 0;
          let closestX = 0;
          bins.forEach(bin => {
            if (Math.abs(parseFloat(bin.dataset.start) - g.value) < Math.abs(parseFloat(bin.dataset.start) - (g.value + (closestX ? bins[0].clientWidth : 0)))) {
              closestX = cumX;
              g.value = parseFloat(bin.dataset.start);
            }
            cumX += bin.clientWidth;
          });
          line.style.left = `${closestX}px`;
        }
        line.querySelector('.grade-value').textContent = getBinLabel(g.value, currentStep);
      });
    }

    // Pro Mode и события — без изменений
    const proModeSwitch = document.getElementById('pro-mode-switch');
    const proModeControls = document.getElementById('pro-mode-controls');
    const widthSlider = document.getElementById('linesWidthSlider');
    const heightSlider = document.getElementById('linesHeightSlider');

    proModeSwitch.addEventListener('change', () => {
      proModeControls.classList.toggle('active', proModeSwitch.checked);
      renderVisualization();
    });

    widthSlider.addEventListener('input', e => {
      const v = e.target.value + 'px';
      document.getElementById('chart-container').style.width = v;
      document.getElementById('chart-container').style.maxWidth = v;
      renderVisualization();
    });

    heightSlider.addEventListener('input', e => {
      document.getElementById('chart-container').style.height = e.target.value + 'px';
      renderVisualization();
    });

    window.addEventListener('DOMContentLoaded', () => {
      ['vacancyFilter','cityFilter','quarterFilter','stepFilter'].forEach(id => {
        document.getElementById(id).addEventListener('change', () => {
          renderVisualization();
          calculateMedians();
        });
      });
      loadData();
    });
  </script>
</body>
</html>
