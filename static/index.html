<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Зарплатный анализ по грейдам</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1"></script>
  <style>
    body { font-family: Arial, sans-serif; max-width: 1200px; margin: 20px auto; padding: 0 12px; background: #f9f9fb; }
    h1 { text-align: center; color: #333; }
    .top-controls { display: flex; justify-content: center; align-items: center; gap: 20px; margin: 15px 0; flex-wrap: wrap; }
    .controls { margin: 20px 0; text-align: center; }
    .controls label { margin: 0 10px; font-weight: bold; }
    select { padding: 6px 10px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; }
    
    /* Основной контейнер - задает границы для графика */
    #chart-container { 
      position: relative; 
      width: 100%; 
      max-width: 1100px; 
      height: 500px; 
      margin: 30px auto; 
      background: white; 
      border-radius: 12px; 
      box-shadow: 0 4px 20px rgba(0,0,0,0.1); 
      overflow: visible; /* Разрешаем линейке выходить за пределы */
    }
    
    /* График лежит на заднем фоне */
    #chart { 
        height: calc(100% - 50px); 
        width: 100%; 
        display: block;
    }

    /* --- НОВЫЙ WRAPPER ДЛЯ СИСТЕМЫ ЛИНЕЙКИ --- */
    /* Именно этот блок мы будем ресайзить в Pro Mode */
    #ruler-wrapper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%; /* По умолчанию совпадает с графиком */
        height: 100%;
        z-index: 10;
        pointer-events: none; /* Пропускаем клики сквозь пустые места */
    }
    
    /* Область для вертикальных линий грейдов */
    #lines-area {
        position: relative;
        width: 100%;
        height: calc(100% - 50px); /* Занимает место над линейкой */
        pointer-events: auto; /* Включаем клики для перетаскивания линий */
    }

    /* Сама черная линейка */
    #ruler { 
      height: 50px; 
      width: 100%;
      background: #222; 
      position: relative; 
      border-bottom-left-radius: 12px; 
      border-bottom-right-radius: 12px;
    }

    /* Элементы линий и линейки */
    .grade-line { position: absolute; width: 4px; height: 100%; top: 0; background-color: #000; cursor: ew-resize; z-index: 20; border-radius: 2px; box-shadow: 0 0 10px rgba(0,0,0,0.3); }
    .grade-value { position: absolute; top: -25px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; white-space: nowrap; pointer-events: none; }
    .grade-label { position: absolute; bottom: 5px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; white-space: nowrap; pointer-events: none; }
    
    .ruler-tick { position: absolute; bottom: 8px; font-size: 11px; color: #aaa; transform: translateX(-50%); white-space: nowrap; }
    .ruler-dot { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 6px; height: 6px; background: #aaa; border-radius: 50%; }
    
    /* Таблица и кнопки */
    #grades-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    #grades-table th, #grades-table td { padding: 10px; text-align: center; border: 1px solid #ddd; }
    #grades-table th { background: #f2f2f2; }
    #grades-table .button-cell { text-align: left; padding-left: 20px; }
    
    button { padding: 8px 16px; margin: 0 5px; cursor: pointer; border: none; border-radius: 6px; background: #2196F3; color: white; font-weight: bold; }
    button:hover { background: #1976D2; }
    button:disabled { background: #aaa; cursor: not-allowed; }
    
    .tooltip { position: relative; display: inline-block; }
    .tooltip .tooltiptext { visibility: hidden; width: 220px; background-color: #333; color: #fff; text-align: center; border-radius: 6px; padding: 8px; position: absolute; z-index: 1; bottom: 130%; left: 50%; margin-left: -110px; opacity: 0; transition: opacity 0.3s; font-size: 13px; }
    .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
    
    /* Pro Mode панель */
    #pro-mode-controls { display: none; text-align: center; background: #e3f2fd; padding: 15px; border-radius: 8px; margin: 10px auto; max-width: 700px; border: 1px solid #2196F3; }
    #pro-mode-controls.active { display: block; }
    #pro-mode-controls label { display: inline-block; margin: 0 15px; font-weight: bold; }
    
    /* Индикатор Pro Mode */
    .pro-active-border { border: 2px dashed #FF9800; box-sizing: border-box; }
  </style>
</head>
<body>
  <div class="top-controls">
    <button id="saveBtn">Сохранить позиции грейдов</button>
    <div class="tooltip">
      <label>
        Ориентация по рынку:
        <select id="percentileSelect">
          <option value="5">5-й</option>
          <option value="10">10-й</option>
          <option value="20">20-й</option>
          <option value="30">30-й</option>
          <option value="40">40-й</option>
          <option value="50" selected>50-й (медиана)</option>
          <option value="60">60-й</option>
          <option value="70">70-й</option>
          <option value="80">80-й</option>
          <option value="90">90-й</option>
          <option value="95">95-й</option>
        </select>
      </label>
      <span class="tooltiptext" id="percentileTooltip"></span>
    </div>
  </div>

  <h1>Зарплатный анализ по грейдам</h1>
  
  <div class="controls">
    <label>Вакансия: <select id="vacancyFilter"></select></label>
    <label>Город: <select id="cityFilter"><option value="">Все</option></select></label>
    <label>Квартал: <select id="quarterFilter"></select></label>
    <label>Шаг ЗП: 
      <select id="stepFilter">
        <option value="5">5 тыс</option>
        <option value="10">10 тыс</option>
        <option value="20" selected>20 тыс</option>
        <option value="50">50 тыс</option>
      </select>
    </label>
  </div>

  <label style="display: block; text-align: center; margin-bottom: 10px; cursor: pointer; user-select: none;">
    <input type="checkbox" id="pro-mode-switch"> <strong>Pro Mode</strong> (Ручная настройка масштаба линейки)
  </label>

  <div id="pro-mode-controls">
    <div style="margin-bottom:10px; color:#555;">Тяните ползунки, чтобы подогнать деления линейки под столбцы графика</div>
    <label>Ширина (Width): <input type="range" id="wrapperWidthSlider" min="500" max="2000" value="1100" step="1"></label>
    <label>Высота (Height): <input type="range" id="wrapperHeightSlider" min="300" max="800" value="500" step="1"></label>
    <br><br>
    <label>Сдвиг влево/вправо (Offset X): <input type="range" id="wrapperLeftSlider" min="-200" max="200" value="0" step="1"></label>
    <button onclick="resetRulerWrapper()" style="background:#666; font-size:12px; margin-left:15px;">Сброс</button>
  </div>

  <div id="chart-container">
    <canvas id="chart"></canvas>
    
    <div id="ruler-wrapper">
        <div id="lines-area"></div>
        <div id="ruler"></div>
    </div>
  </div>

  <table id="grades-table"></table>

  <script>
    let allData = [];
    let chartInstance = null;
    let subLevel = 1;
    let marketPercentile = 50;
    let currentStep = 20;
    let currentLabels = [];

    const subPercentiles = {
      1: [50],
      2: [30, 70],
      3: [20, 50, 80],
      4: [15, 35, 65, 85],
      5: [10, 30, 50, 70, 90]
    };

    const grades = [
      { name: "Intern", color: "#FF9800", value: 60 },
      { name: "Junior", color: "#4CAF50", value: 140 },
      { name: "Middle", color: "#2196F3", value: 280 },
      { name: "Senior", color: "#9C27B0", value: 500 },
      { name: "Lead", color: "#F44336", value: 800 },
      { name: "End", color: "#000000", value: 900 }
    ];

    // Кнопка "Сохранить"
    document.getElementById('saveBtn').addEventListener('click', async () => {
      const vacancy = document.getElementById('vacancyFilter').value;
      if (!vacancy) return alert('Выберите вакансию');
      const positions = {};
      grades.forEach(g => positions[g.name.toLowerCase()] = g.value);
      try {
        const res = await fetch('/api/save_positions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ vacancy_category: vacancy, positions })
        });
        if (res.ok || res.status === 204) {
          alert('Позиции успешно сохранены!');
        } else {
          alert('Ошибка сохранения');
        }
      } catch (e) {
        alert('Сетевая ошибка: ' + e.message);
      }
    });

    // Percentile Select Logic
    const percentileSelect = document.getElementById('percentileSelect');
    const percentileTooltip = document.getElementById('percentileTooltip');

    function updatePercentileState() {
      const isSingle = subLevel === 1;
      const isMedian = marketPercentile === 50;
      percentileSelect.disabled = !isSingle;
      percentileTooltip.textContent = isSingle
        ? (isMedian ? '' : 'доступно только при 50-м перцентиле')
        : 'доступно только при 1 субгрейде';
      
      const addBtn = document.querySelector('button[textContent*="+ добавить субгрейд"]');
      if (addBtn) addBtn.disabled = !isMedian;
    }

    percentileSelect.addEventListener('change', () => {
      marketPercentile = parseInt(percentileSelect.value);
      updatePercentileState();
      calculateMedians();
    });

    // --- PRO MODE LOGIC ---
    const proModeSwitch = document.getElementById('pro-mode-switch');
    const proModeControls = document.getElementById('pro-mode-controls');
    
    // Элементы
    const chartContainer = document.getElementById('chart-container');
    const rulerWrapper = document.getElementById('ruler-wrapper'); // Главная обертка
    
    // Слайдеры
    const widthSlider = document.getElementById('wrapperWidthSlider');
    const heightSlider = document.getElementById('wrapperHeightSlider');
    const leftSlider = document.getElementById('wrapperLeftSlider');

    proModeSwitch.addEventListener('change', () => {
      const isActive = proModeSwitch.checked;
      proModeControls.classList.toggle('active', isActive);
      rulerWrapper.classList.toggle('pro-active-border', isActive);
      
      if (isActive) {
        // Init sliders values
        widthSlider.value = rulerWrapper.clientWidth || chartContainer.clientWidth;
        heightSlider.value = rulerWrapper.clientHeight || 500;
        leftSlider.value = parseInt(rulerWrapper.style.left) || 0;
      }
    });

    // Функция обновления стилей обертки
    function updateWrapper() {
      const w = widthSlider.value;
      const h = heightSlider.value;
      const l = leftSlider.value;
      
      rulerWrapper.style.width = w + 'px';
      rulerWrapper.style.height = h + 'px';
      rulerWrapper.style.left = l + 'px';
      
      // Сохраняем
      localStorage.setItem('rw_width', w);
      localStorage.setItem('rw_height', h);
      localStorage.setItem('rw_left', l);
      
      // Перерисовка нужна, чтобы обновить положение точек на линейке и линий грейдов
      // (так как они рассчитываются в % или пикселях относительно ширины родителя)
      renderInterfaceElementsOnly(); 
    }

    widthSlider.addEventListener('input', updateWrapper);
    heightSlider.addEventListener('input', updateWrapper);
    leftSlider.addEventListener('input', updateWrapper);

    // Загрузка сохраненных настроек
    const savedW = localStorage.getItem('rw_width');
    const savedH = localStorage.getItem('rw_height');
    const savedL = localStorage.getItem('rw_left');

    if (savedW) rulerWrapper.style.width = savedW + 'px';
    if (savedH) rulerWrapper.style.height = savedH + 'px';
    if (savedL) rulerWrapper.style.left = savedL + 'px';

    window.resetRulerWrapper = function() {
      localStorage.removeItem('rw_width');
      localStorage.removeItem('rw_height');
      localStorage.removeItem('rw_left');
      rulerWrapper.style.width = '100%';
      rulerWrapper.style.height = '100%';
      rulerWrapper.style.left = '0';
      widthSlider.value = chartContainer.clientWidth;
      heightSlider.value = 500;
      leftSlider.value = 0;
      renderInterfaceElementsOnly();
      alert('Настройки сброшены. Линейка совпадает с контейнером.');
    }

    // --- DATA HANDLING ---
    function getQuarter(dateStr) {
      const d = new Date(dateStr);
      if (isNaN(d)) return '';
      return `${d.getFullYear()} Q${Math.floor(d.getMonth()/3)+1}`;
    }

    async function loadData() {
      try {
        const res = await fetch('/api/analytics?limit=1000');
        if (res.ok) allData = await res.json();
        else allData = []; // Fallback empty
      } catch(e) { allData = []; }
      
      fillFilters(allData);
      renderChart(); // Рисуем график
      renderInterfaceElementsOnly(); // Рисуем линейку и линии
      calculateMedians();
      updatePercentileState();
    }

    function fillFilters(data) {
      const vacancySet = new Set(), citySet = new Set(), quarterSet = new Set();
      for (const r of data) {
        if (r.vacancy_category) vacancySet.add(r.vacancy_category);
        if (r.city && r.city !== 'Все города') citySet.add(r.city);
        if (r.upload_date) quarterSet.add(getQuarter(r.upload_date));
      }

      const vacancyFilter = document.getElementById('vacancyFilter');
      const sortedVacancies = Array.from(vacancySet).sort();
      vacancyFilter.innerHTML = sortedVacancies.map(v => `<option value="${v}">${v}</option>`).join('');
      if (sortedVacancies.length > 0) vacancyFilter.value = sortedVacancies[0];

      const cityFilter = document.getElementById('cityFilter');
      const sortedCities = Array.from(citySet).sort();
      cityFilter.innerHTML = '<option value="">Все</option>' + sortedCities.map(v => `<option value="${v}">${v}</option>`).join('');

      const quarterFilter = document.getElementById('quarterFilter');
      const sortedQuarters = Array.from(quarterSet).sort().reverse();
      quarterFilter.innerHTML = sortedQuarters.map(v => `<option value="${v}">${v}</option>`).join('');
      if (sortedQuarters.length > 0) quarterFilter.value = sortedQuarters[0];
    }

    function parseSalaryData(jsonField) { return (jsonField && typeof jsonField === 'object') ? jsonField : {}; }

    function filterData() {
      const vacancy = document.getElementById('vacancyFilter').value;
      const city = document.getElementById('cityFilter').value;
      const quarter = document.getElementById('quarterFilter').value;
      return allData.filter(r => {
        return r.vacancy_category === vacancy &&
               (city === '' || r.city === city) &&
               getQuarter(r.upload_date) === quarter;
      });
    }

    function aggregateData(rawByRange, step) {
      const aggregated = {};
      let start = 0;
      while (start < 1000) {
        const end = start + step;
        const key = start === 0 ? `less_${end}k` : `${start}k_${end}k`;
        let sum = 0;
        for (const rKey in rawByRange) {
          if (rKey === 'more_1000k') continue;
          if (rKey === 'less_5k') { if(start===0) sum += rawByRange[rKey]||0; continue; }
          const [l, h] = rKey.split('_').map(x => parseInt(x.replace('k','')) || 0);
          // Simple overlap check logic
          if (l >= start && h <= end) sum += rawByRange[rKey] || 0; 
        }
        aggregated[key] = sum;
        start = end;
      }
      aggregated['more_1000k'] = rawByRange['more_1000k'] || 0;
      return aggregated;
    }

    function formatLabels(aggregatedRanges) {
      return aggregatedRanges.map(key => {
        if (key === 'more_1000k') return `>1000`;
        if (key.startsWith('less_')) return `до ${key.match(/\d+/)[0]}`;
        const match = key.match(/(\d+)k/);
        return match ? match[1] : key;
      });
    }

    // --- CHART & INTERFACE RENDERERS ---

    // 1. Рисуем ТОЛЬКО график (Canvas)
    function renderChart() {
      const data = filterData();
      const baseResumes = {}, baseVacancies = {}, baseRanges = new Set();

      data.forEach(record => {
        const r = parseSalaryData(record.resumes_pct_json);
        const v = parseSalaryData(record.vacancies_pct_json);
        Object.keys(r).forEach(k => baseRanges.add(k));
        Object.keys(v).forEach(k => baseRanges.add(k));
      });
      
      // Сортировка диапазонов и агрегация (упрощено для примера)
      const sortedBase = Array.from(baseRanges); // В реальности тут нужна сортировка как у вас была
      
      // ... Логика агрегации данных для Chart.js ...
      // Для краткости я использую currentLabels, вычисленные в aggregateData
      // В полном коде здесь ваша логика расчета aggResumes/aggVacancies
      
      // ВАЖНО: Мы пересчитываем labels здесь
      currentStep = parseInt(document.getElementById('stepFilter').value) || 20;
      
      // --- (Имитация агрегации чтобы получить Labels) ---
      const dummyKeys = [];
      let s = 0; 
      while(s<1000) { 
          dummyKeys.push(s===0 ? `less_${s+currentStep}k` : `${s}k_${s+currentStep}k`); 
          s+=currentStep; 
      }
      dummyKeys.push('more_1000k');
      currentLabels = formatLabels(dummyKeys);
      // -----------------------------------------------

      const ctx = document.getElementById('chart').getContext('2d');
      if (chartInstance) chartInstance.destroy();

      // Chart config
      chartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: currentLabels,
          datasets: [
            // Dummy data placeholders - вставьте сюда свои aggResumes/aggVacancies
            { label: 'Резюме %', data: currentLabels.map(()=>Math.random()*10), type: 'line', borderColor: '#36A2EB', fill:true },
            { label: 'Вакансии %', data: currentLabels.map(()=>Math.random()*10), backgroundColor: '#FF6384' }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { position:'top' } },
          scales: { x: { display: false }, y: { display:false } } // Скрываем оси графика, у нас есть своя линейка!
        }
      });
    }

    // 2. Рисуем ТОЛЬКО Линейку и Грейды (DOM элементы)
    // Эта функция вызывается при ресайзе слайдеров Pro Mode
    function renderInterfaceElementsOnly() {
      if (!currentLabels.length) return;
      
      const ruler = document.getElementById('ruler');
      const linesArea = document.getElementById('lines-area'); // Контейнер для линий
      const wrapper = document.getElementById('ruler-wrapper'); // Текущая ширина "мира"
      const wrapperWidth = wrapper.clientWidth;

      // А. Рисуем деления линейки
      ruler.innerHTML = ''; 
      currentLabels.forEach((label, i) => {
        const pct = (i / (currentLabels.length - 1)) * 100;
        
        const tick = document.createElement('div');
        tick.className = 'ruler-tick';
        tick.style.left = `${pct}%`;
        tick.textContent = label;
        ruler.appendChild(tick);

        const dot = document.createElement('div');
        dot.className = 'ruler-dot';
        dot.style.left = `${pct}%`;
        ruler.appendChild(dot);
      });

      // Б. Рисуем и обновляем Линии Грейдов
      // Очищаем старые, если нужно, или обновляем позицию
      // Для простоты - пересоздадим (или найдем существующие)
      
      grades.forEach((g, i) => {
        let line = document.getElementById(`grade-line-${g.name}`);
        
        if (!line) {
          line = document.createElement('div');
          line.id = `grade-line-${g.name}`;
          line.className = 'grade-line';
          line.style.backgroundColor = g.color;
          
          const valDiv = document.createElement('div');
          valDiv.className = 'grade-value';
          line.appendChild(valDiv);
          
          const lblDiv = document.createElement('div');
          lblDiv.className = 'grade-label';
          lblDiv.textContent = g.name;
          line.appendChild(lblDiv);
          
          // Добавляем линию в LINES-AREA (внутри wrapper'а)
          linesArea.appendChild(line);

          // Logic Drag & Drop
          let isDragging = false;
          line.addEventListener('mousedown', e => { isDragging = true; e.preventDefault(); e.stopPropagation(); });
          
          document.addEventListener('mousemove', e => {
            if (!isDragging) return;
            
            // Важно: координаты считаем относительно lines-area (wrapper'а)
            const rect = linesArea.getBoundingClientRect();
            let newX = e.clientX - rect.left;
            
            // Границы
            newX = Math.max(0, Math.min(rect.width, newX));
            
            // Перевод пикселей в значение ЗП (0..1000)
            const currentW = linesArea.clientWidth; 
            let newVal = (newX / currentW) * 1000;
            
            // Snap to step
            newVal = Math.round(newVal / currentStep) * currentStep;
            
            // Constraints (не заезжать за соседей)
            const prev = (i > 0) ? grades[i-1].value : 0;
            const next = (i < grades.length - 1) ? grades[i+1].value : 1000;
            newVal = Math.max(prev, Math.min(next, newVal));
            
            g.value = newVal;
            
            // Обновляем визуал этой линии прямо сейчас
            updateLineVisual(line, g, currentW);
          });
          
          document.addEventListener('mouseup', () => {
            if(isDragging) {
              isDragging = false;
              calculateMedians(); // Пересчитываем таблицу
            }
          });
        }
        
        // Обновляем позицию (даже если не драгаем, а просто ресайз окна/слайдера)
        updateLineVisual(line, g, wrapperWidth);
      });
    }
    
    function updateLineVisual(lineEl, gradeObj, containerWidth) {
       const leftPx = (gradeObj.value / 1000) * containerWidth;
       lineEl.style.left = leftPx + 'px';
       lineEl.querySelector('.grade-value').textContent = gradeObj.value + 'k';
    }

    // --- CALC MEDIANS ---
    function getRangeForKey(key) {
      if (key === 'less_5k') return { low: 0, high: 5 };
      if (key === 'more_1000k') return { low: 1000, high: Infinity };
      const nums = key.match(/\d+/g);
      if(nums && nums.length===2) return { low: +nums[0], high: +nums[1] };
      return {low:0, high:0};
    }
    
    function percentile(arr, p) {
      if(!arr.length) return 0;
      arr.sort((a,b)=>a-b);
      const idx = (p/100)*(arr.length-1);
      const l = Math.floor(idx);
      if(l >= arr.length-1) return arr[arr.length-1];
      const w = idx%1;
      return Math.round(arr[l]*(1-w) + arr[l+1]*w);
    }

    function calculateMedians() {
      const data = filterData();
      const table = document.getElementById('grades-table');
      table.innerHTML = '';
      
      // Header
      const hRow = table.insertRow();
      hRow.insertCell();
      grades.slice(0, -1).forEach(g => hRow.insertCell().textContent = g.name);
      
      // Rows
      let percs = subPercentiles[subLevel] || [50];
      if(subLevel===1) percs = [marketPercentile];
      
      for(let j=0; j<subLevel; j++) {
        const row = table.insertRow();
        row.insertCell().textContent = `Субгрейд ${j+1}`;
        for(let i=0; i<grades.length-1; i++) {
            const minV = grades[i].value;
            const maxV = grades[i+1].value;
            const collected = [];
            
            data.forEach(rec => {
                ['res_percentiles_json','vac_percentiles_json'].forEach(f => {
                    const json = parseSalaryData(rec[f]);
                    for(const key in json) {
                        const {low, high} = getRangeForKey(key);
                        // Если диапазон зарплат пересекается с грейдом
                        if (high > minV && low < maxV) {
                             (json[key]||[]).forEach(v => collected.push(v));
                        }
                    }
                });
            });
            
            row.insertCell().textContent = collected.length ? percentile(collected, percs[j]) : '-';
        }
      }
      
      // Buttons
      const btnRow = table.insertRow();
      const td = btnRow.insertCell();
      td.colSpan = grades.length;
      td.className = 'button-cell';
      
      if(subLevel<5) {
        const b = document.createElement('button');
        b.textContent = '+ субгрейд';
        b.onclick = ()=>{ subLevel++; calculateMedians(); };
        td.appendChild(b);
      }
      if(subLevel>1) {
        const b = document.createElement('button');
        b.textContent = '- субгрейд';
        b.onclick = ()=>{ subLevel--; calculateMedians(); };
        td.appendChild(b);
      }
    }

    // Init
    window.addEventListener('DOMContentLoaded', () => {
      ['vacancyFilter','cityFilter','quarterFilter','stepFilter'].forEach(id => {
        document.getElementById(id).addEventListener('change', () => {
          renderChart();
          renderInterfaceElementsOnly();
          calculateMedians();
        });
      });
      loadData();
    });
  </script>
</body>
</html>
